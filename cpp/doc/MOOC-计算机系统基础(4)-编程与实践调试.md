# 计算机系统基础（四）：编程与调试实践

## contents
- [计算机系统基础（四）：编程与调试实践](#计算机系统基础四编程与调试实践)
  - [contents](#contents)
  - [week1 开发环境安装和使用](#week1-开发环境安装和使用)
    - [gcc使用](#gcc使用)
    - [objdump使用](#objdump使用)
    - [gdb基本使用](#gdb基本使用)
      - [补充gdb命令](#补充gdb命令)
  - [week2 c语言编程实践](#week2-c语言编程实践)
    - [位运算 = 逻辑运算 + 移位运算](#位运算--逻辑运算--移位运算)
      - [按位逻辑运算 = 按位取反~ 按位与& 按位或| 按位异或^](#按位逻辑运算--按位取反-按位与-按位或-按位异或)
      - [移位运算 = 算数移位 + 逻辑移位](#移位运算--算数移位--逻辑移位)
    - [浮点数精度](#浮点数精度)
      - [如何减小浮点数累加运算中精度丢失问题？](#如何减小浮点数累加运算中精度丢失问题)
    - [cache友好代码](#cache友好代码)
    - [信号处理函数](#信号处理函数)
## week1 开发环境安装和使用

### gcc使用

**gcc分步骤使用**
gcc -E hello.c -o hello.i   #预处理  
    gcc -S hello.i -o hello.s   #编译
        gcc -c hello.s -o hello.o #汇编
            gcc hello.o -o hello    #链接

**gcc直接生成可执行文件**
gcc hello.c -o hello

### objdump使用
ojbdump将`重定位文件`与`可执行文件`反汇编得到汇编代码。重定位文件的起始地址从0开始，但可执行文件不是。

**用法**:  -S选项 添加C代码作为对照 
`objdump -S hello.o > hello.s`  #反汇编重定位文件
`objdump -S hello > hello.s`    #反汇编可执行文件

`objdump -d hello > hello.s`    #也可以利用-d选项

### gdb基本使用

step1:启动gdb的两种方法
    方法1) `gdb hello`
    方法2) `gdb`
       `file hello`

step2:设置断点
    在函数入口设置断点: `break main`
    按照行号设置断点：`break hello.c:3`

step3:启动程序并运行到断点 `run` `r`

step4:**查看当前状态**
    查看**程序指针寄存器eip**的值 `i r eip` 表示下一条指令的位置
    查看所有**通用寄存器**的值 `i r` 或者全拼`info register`

    通过地址，查看**内存单元**  `x命令`
        `x/8xb 0x4011b2`从地址0x4011b2开始，显示8个存储单元，16进制显示 ，每个存储单元对应1字节
           |||__一个存储单元对应一个字节
           ||__按16进制显示
           |__显示8个内存单元
```sh
(gdb) x/8xb 0x4011b2
0x4011b2 <main+25>:     0x83    0xec    0x0c    0x8d    0x90    0x08    0xe0    0xff
```  

        `x/2dw 0x4011b2`从地址0x4011b2开始，显示2个32位的存储单元内容，并以10进制显示
```sh
(gdb) x/2dw 0x4011b2
0x4011b2 <main+25>:     -1928532861     -2094960
```

    查看**栈帧**
        查看栈帧范围`i r esp ebp`
        计算栈帧的总字节数y=ebp-esp+4,z=y/4  
        显示当前栈帧
            `x/yxb $esp`    #y是上面计算出来的字节数,每字节用16进制打印内存单元
            `x/zxw $esp`    #z=y/4，,每32位用16进制打印每个内存单元
step5:继续执行下一条指令或语句
    执行一条机器指令：`si`
    执行一条C语句：`s`

step6: 退出gdb `quit`

#### 补充gdb命令
`info`
    - 查看所有全局和静态变量 `info variables`  注意会显示很多
    - 查看当前栈帧的局部变量 `info locals`
    - 查看当前函数的参数 `info args`

## week2 c语言编程实践

### 位运算 = 逻辑运算 + 移位运算

#### 按位逻辑运算 = 按位取反~ 按位与& 按位或| 按位异或^

按位异或,又称`半加`运算，满足**交换律**与**结合律**
数a经过奇数次异或等于自身，偶数次异或等于0.eg, a^a=0,a^a^a=a

利用异或实现`原位交换`
#### 移位运算 = 算数移位 + 逻辑移位

`逻辑移位`对应无符号数移位，最高位补0
`算数移位`对应有符号数移位，最高位补符号位

### 浮点数精度

float32 只能显示7位十进制有效数字，第8位不准确

`浮点数的大数吃小数的问题` 大数与小数进行加减运算时，小数的精度丢失

#### 如何减小浮点数累加运算中精度丢失问题？ 
思路：尽可能让两个大小相同的数运算
浮点数之父的**Kahan累加算法**
```c
//累加4百万次0.1
int main()
{
    float sum=0;
    float c=0; //每次累加的舍入误差
    float y,t;
    int i;

    for(i=0; i<4000000; i++>)
    {
        y=0.1 - c;
        t=sum + y; //将每次的舍入误差作为加数
        c=(t-sum)-y;
        sum = t;
    }
    printf("sum=%f\n", sum);

    return 0;
}
```

### cache友好代码
### 信号处理函数