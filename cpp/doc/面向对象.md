- [Object Based 基于对象:单一class的设计](#object-based-基于对象单一class的设计)
  - [class without pointer member](#class-without-pointer-member)
  - [constructor(ctor，构造函数)](#constructorctor构造函数)
    - [initializaton list（初始化列表）](#initializaton-list初始化列表)
    - [设计模式之——singleton(单件)](#设计模式之singleton单件)
    - [默认构造函数](#默认构造函数)
    - [`pass by value` VS `pass by reference(to const)`](#pass-by-value-vs-pass-by-referenceto-const)
    - [`return by value` VS `return by reference(to const)`](#return-by-value-vs-return-by-referenceto-const)
    - [friend(友元)](#friend友元)
  - [class with pointer member](#class-with-pointer-member)
- [Object oriented 面向对象：多重class的设计，要考虑class直接的关系](#object-oriented-面向对象多重class的设计要考虑class直接的关系)

# Object Based 基于对象:单一class的设计

## class without pointer member
以class complex为例 [](./侯捷%20C++%20%20面向对象上/complex.h)

## constructor(ctor，构造函数)
**构造函数是什么？**
构造函数是类的特殊成员函数，目的是为**初始化**对象的**数据成员**。

**构造函数 VS 普通函数**
- 函数名字——构造函数的名字与类的名字相同
- 返回值——构造函数没有返回值
- 何时调用——有对象被创建的时候，自动调用构造函数
- 默认生成构造函数——如果不指定，则编译器会生成一个空的默认构造函数

### initializaton list（初始化列表）
默认构造函数调用时，首先调用各成员的默认构造函数，然后调用赋值构造再赋一次值。初始化列表直接使用copy constructor来初始化成员，效率更高。

**使用默认构造函数初始化 data member**
```cpp
class complex
{
public:
  complex (double r = 0, double i = 0)
  {
    re = r;
    im = i;
  }
private:
  double re, im;
}
```

**使用initiallization list初始化 data member**
```cpp
class complex
{
public:
  complex (double r = 0, double i = 0): re (r), im (i) { }
private:
  double re, im;
}
```
### 设计模式之——singleton(单件)
设计为singleton的class，只有static数据成员，因此所有class共享一份static data member。
特征构造函数为私有。

```cpp
class A{
  public:
    static A& getInstance();
    setup();
  
  private:
    A();//构造函数是私有
}

A& A::getInstance(){
  static A a; //class A只能创建一个实例，只能通过getInstance来获取static member
  return a;
}
```
### 默认构造函数
默认构造函数是无参构造函数`class_name()`，如果所有参数都带默认值也可作为默认构造函数`class_name(parm1=default1)`

### `pass by value` VS `pass by reference(to const)`
设计类时，优先考虑通过reference传递参数

### `return by value` VS `return by reference(to const)` 
设计类时，优先考虑通过返回reference

### friend(友元)
**class的友元函数可以访问私有成员**
```cpp
class complex
{
public:
  complex (double r = 0, double i = 0): re (r), im (i) { }
private:
  double re, im;

  // class的友元函数可以访问私有成员
  friend complex& __doapl (complex *, const complex&);
};

// __doapl函数是class complex的友元，所以可访问complex的私有成员
inline complex&
__doapl (complex* ths, const complex& r)
{
  ths->re += r.re;
  ths->im += r.im;
  return *ths;
}
```

**相同class的各个object互为友元**
```cpp
class complex
{
public:
  complex (double r = 0, double i = 0): re (r), im (i) { }

  // param也是class complex，所以func中可以直接范围param的私有成员
  int func(const complex& param)
  {
    return param.re + param>im;
  }

private:
  double re, im;
};

### 移动构造

`右值引用`就是必须绑定到右值的引用，左值的引用用&，而右值的引用则用&&。右值引用有一个重要的性质，即**只能绑定到一个将要销毁的对象**。

通俗地说，右值通常为临时变量，字面值，未接受的返回值等等，它们没有固定地址。
```cpp
int x = 30;
int &r = x;  //正确，左值引用
int &&r = x; //错误，x为左值，&&r为右值引用
int &&r = 3; //正确，右值引用
const int &r = 3;  //正确，const左值可以对右值引用
```


## class with pointer member

# Object oriented 面向对象：多重class的设计，要考虑class直接的关系